server {
    listen 8080;
    set $token "123456";
    set $white_list "127.0.0.1,192.168.16.212";

    default_type application/json;

    # 权限判断，IP白名单和token
    access_by_lua_block {
        local cjson = require "cjson"

        local result_data = {}
        result_data["code"] = 0
        result_data["msg"] = "ok"
        result_data["data"] = {}

        -- 判断调用方是否在白名单
        local cip = ngx.var.remote_addr
        if string.find(ngx.var.white_list, cip) == nil then
            result_data["code"] = 10002
            result_data["msg"] = "无访问权限"
            ngx.say(cjson.encode(result_data))
            ngx.exit(200)
        end

        -- 判断header中的token是否正确
        local headers = ngx.req.get_headers()
        if headers.token ~= ngx.var.token then
            result_data["code"] = 10001
            result_data["msg"] = "无访问权限"
            ngx.say(cjson.encode(result_data))
            ngx.exit(200)
        end
    }

    location = /upstream/servers {
        content_by_lua_block {
            local cjson = require "cjson"
            local upstream = require "ngx.upstream"
            local get_primary_peers = upstream.get_primary_peers
            local upstream_name = ngx.var.arg_upstream_name
            local status = ngx.var.arg_status
            local request_method = string.upper(ngx.var.request_method)
            local servers = {}

            local result_data = {}
            result_data["code"] = 0
            result_data["msg"] = "ok"
            result_data["data"] = {}

            if request_method == "GET" then
                -- 判断upstream是否存在，或者是否配置了后端服务
                local srvs, err = get_primary_peers(upstream_name)
                if not srvs then
                    result_data["code"] = 11000
                    result_data["msg"] = "upstream不存在或未设置后端服务"
                    ngx.say(cjson.encode(result_data))
                    ngx.exit(200)
                end

                for _, srv in ipairs(srvs) do
                    if status == "down" and srv.down == true then
                        table.insert(servers, srv.name)
                    end
                    if status == "up" and srv.down == nil then
                        table.insert(servers, srv.name)
                    end
                    if status == nil then
                        table.insert(servers, srv.name)
                    end
                end
                -- 返回符合要求的后台服务
                if #servers > 0 then
                    result_data["data"]["servers"] = servers
                end
                ngx.say(cjson.encode(result_data))
                ngx.exit(200)
            end
        }
    }

    location = /upstream/servers/down {
        lua_need_request_body on;
        content_by_lua_block {
            local cjson = require "cjson"
            local upstream = require "ngx.upstream"
            local get_primary_peers = upstream.get_primary_peers
            local request_method = string.upper(ngx.var.request_method)
            local down_servers = {}

            local result_data = {}
            result_data["code"] = 0
            result_data["msg"] = "ok"
            result_data["data"] = {}

            if request_method == "POST" then
                local data = ngx.req.get_body_data()
                data = cjson.decode(data)
                local upstream_name = data.upstream_name
                if upstream_name == nil or upstream_name == "" then
                    result_data["code"] = 10000
                    result_data["msg"] = "参数不正确"
                    ngx.say(cjson.encode(result_data))
                    ngx.exit(200)
                end
                local servers = data.servers
                if servers == nil or servers == "" then
                    result_data["code"] = 10000
                    result_data["msg"] = "参数不正确"
                    ngx.say(cjson.encode(result_data))
                    ngx.exit(200)
                end
                local srvs = get_primary_peers(upstream_name)
                for i, srv in ipairs(srvs) do
                    if string.find(servers, srv.name) then
                        upstream.set_peer_down(upstream_name, false, i - 1, false)
                        table.insert(down_servers, srv.name)
                    end
                end
                result_data["data"]["servers"] = down_servers
                ngx.say(cjson.encode(result_data))
            end
        }
    }

    location = /upstream/servers/up {
        lua_need_request_body on;
        content_by_lua_block {
            local cjson = require "cjson"
            local upstream = require "ngx.upstream"
            local get_primary_peers = upstream.get_primary_peers
            local get_upstreams = upstream.get_upstreams
            local request_method = string.upper(ngx.var.request_method)
            local up_servers = {}
            local result_data = {}
            result_data["code"] = 0
            result_data["msg"] = "ok"
            result_data["data"] = {}

            if request_method == "POST" then
                local data = ngx.req.get_body_data()
                data = cjson.decode(data)
                local upstream_name = data.upstream_name
                if upstream_name == nil or upstream_name == "" then
                    result_data["code"] = 10000
                    result_data["msg"] = "参数不正确"
                    ngx.say(cjson.encode(result_data))
                    ngx.exit(200)
                end
                local servers = data.servers
                if servers == nil or servers == "" then
                    result_data["code"] = 10000
                    result_data["msg"] = "参数不正确"
                    ngx.say(cjson.encode(result_data))
                    ngx.exit(200)
                end
                local srvs = get_primary_peers(upstream_name)
                for i, srv in ipairs(srvs) do
                    if string.find(servers, srv.name) then
                        upstream.set_peer_down(upstream_name, false, i - 1, false)
                        table.insert(up_servers, srv.name)
                    end
                end
                result_data["data"]["servers"] = up_servers
                ngx.say(cjson.encode(result_data))
            end
        }
    }
}
